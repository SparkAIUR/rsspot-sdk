#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Any


def _safe_name(value: str) -> str:
    out = []
    for char in value:
        if char.isalnum():
            out.append(char.lower())
        else:
            out.append("_")
    collapsed = "".join(out).strip("_")
    while "__" in collapsed:
        collapsed = collapsed.replace("__", "_")
    return collapsed or "operation"


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate lightweight OpenAPI operation index")
    parser.add_argument("--schema", default="openapi/openapi.json", help="Input schema file")
    parser.add_argument(
        "--out",
        default="src/rsspot/generated/openapi_index.py",
        help="Output python module",
    )
    args = parser.parse_args()

    schema_path = Path(args.schema)
    if not schema_path.exists():
        raise RuntimeError(f"schema file not found: {schema_path}")

    payload = json.loads(schema_path.read_text(encoding="utf-8"))
    if not isinstance(payload, dict):
        raise RuntimeError("schema file did not decode into a JSON object")

    paths = payload.get("paths")
    if not isinstance(paths, dict):
        raise RuntimeError("schema does not contain a 'paths' object")

    operations: list[dict[str, str]] = []
    for raw_path, methods in sorted(paths.items()):
        if not isinstance(raw_path, str) or not isinstance(methods, dict):
            continue
        for method, operation in sorted(methods.items()):
            if method.lower() not in {"get", "post", "put", "patch", "delete", "head", "options"}:
                continue
            if not isinstance(operation, dict):
                continue
            operation_id = operation.get("operationId")
            if not isinstance(operation_id, str) or not operation_id:
                operation_id = _safe_name(f"{method}_{raw_path}")
            operations.append(
                {
                    "operation_id": operation_id,
                    "method": method.upper(),
                    "path": raw_path,
                    "summary": str(operation.get("summary", "")),
                }
            )

    out_path = Path(args.out)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    rendered = [
        "from __future__ import annotations",
        "",
        "# Generated by scripts/generate_openapi_index.py",
        "OPERATIONS: list[dict[str, str]] = [",
    ]
    for op in operations:
        rendered.append(
            f"    {{'operation_id': {op['operation_id']!r}, 'method': {op['method']!r}, 'path': {op['path']!r}, 'summary': {op['summary']!r}}},"
        )
    rendered.append("]")
    rendered.append("")
    out_path.write_text("\n".join(rendered), encoding="utf-8")

    print(f"generated {len(operations)} operations in {out_path}")


if __name__ == "__main__":
    main()
